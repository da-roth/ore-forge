diff --git a/QuantExt/qle/pricingengines/analyticlgmcdsoptionengine.cpp b/QuantExt/qle/pricingengines/analyticlgmcdsoptionengine.cpp
index bcea0ee..0f23924 100644
--- a/QuantExt/qle/pricingengines/analyticlgmcdsoptionengine.cpp
+++ b/QuantExt/qle/pricingengines/analyticlgmcdsoptionengine.cpp
@@ -73,11 +73,11 @@ void AnalyticLgmCdsOptionEngine::calculate() const {
         t_[i + 1] = yts->timeFromReference(cpn->date());
         Real mid = (t_[i] + t_[i + 1]) / 2.0;
         if (arguments_.swap->settlesAccrual()) {
-            Real accStartTime = i == 0 ? yts->timeFromReference(cpn->accrualStartDate()) : t_[i];
+            Real accStartTime = i == 0 ? Real(yts->timeFromReference(cpn->accrualStartDate())) : Real(t_[i]);
             // mid > accStartTime practically always the case?
-            accrualSettlementAmount = mid > accStartTime ? swapSpread * cpn->accrualPeriod() * (mid - accStartTime) /
-                                                               (t_[i + 1] - accStartTime)
-                                                         : 0.0;
+            accrualSettlementAmount = mid > accStartTime ? Real(swapSpread * cpn->accrualPeriod() * (mid - accStartTime) /
+                                                               (t_[i + 1] - accStartTime))
+                                                         : Real(0.0);
         }
         C[i] = ((1.0 - recoveryRate_) - accrualSettlementAmount) * yts->discount(mid) / yts->discount(tex_);
         D[i] = swapSpread * cpn->accrualPeriod() * yts->discount(t_[i + 1]) / yts->discount(tex_);
diff --git a/QuantExt/qle/pricingengines/analyticlgmswaptionengine.cpp b/QuantExt/qle/pricingengines/analyticlgmswaptionengine.cpp
index 4c7612b..d9cc78d 100644
--- a/QuantExt/qle/pricingengines/analyticlgmswaptionengine.cpp
+++ b/QuantExt/qle/pricingengines/analyticlgmswaptionengine.cpp
@@ -242,7 +242,7 @@ void AnalyticLgmSwaptionEngine::calculate() const {
     if (!caching_ || !lgm_alpha_constant_ || zetaex_ == Null<Real>()) {
         zetaex_ = p_->zeta(p_->termStructure()->timeFromReference(expiry)) -
                   p_->zeta(p_->termStructure()->timeFromReference(reference)) +
-                  (applyZetaShift_ ? zetaShift_ * zetaShiftT_ : 0.0);
+                  (applyZetaShift_ ? Real(zetaShift_ * zetaShiftT_) : Real(0.0));
     }
 
     Brent b;
@@ -260,14 +260,14 @@ void AnalyticLgmSwaptionEngine::calculate() const {
                                 0.0, 0.01);
             } catch (const std::exception& e) { // Try Brent with optimized starting point
                 Bisection b2;
-                double startValue = b2.solve(
+                Real startValue = b2.solve(
                     std::bind(&AnalyticLgmSwaptionEngine::yStarHelper, this, std::placeholders::_1), 1.0E-2, -3.0, 3.0);
                 yStar = b.solve(std::bind(&AnalyticLgmSwaptionEngine::yStarHelper, this, std::placeholders::_1), 1.0E-6,
                                 startValue, 0.01);
             }
         } catch (const std::exception& e) { // Try Brent with another optimized starting point
             Bisection b2;
-            double startValue2 = b2.solve(
+            Real startValue2 = b2.solve(
                 std::bind(&AnalyticLgmSwaptionEngine::yStarHelper, this, std::placeholders::_1), 1.0E-2, -10.0, 10.0);
             yStar = b.solve(std::bind(&AnalyticLgmSwaptionEngine::yStarHelper, this, std::placeholders::_1), 1.0E-6,
                             startValue2, 0.01);
diff --git a/QuantExt/qle/pricingengines/blackbondoptionengine.cpp b/QuantExt/qle/pricingengines/blackbondoptionengine.cpp
index a84a18f..1a222f1 100644
--- a/QuantExt/qle/pricingengines/blackbondoptionengine.cpp
+++ b/QuantExt/qle/pricingengines/blackbondoptionengine.cpp
@@ -66,12 +66,12 @@ void BlackBondOptionEngine::calculate() const {
         cfRes.type = "Underlying_Bond__" + cfRes.type;
     }
 
-    Real knockOutProbability = defaultCurve_.empty() ? 0.0 : 1.0 - defaultCurve_->survivalProbability(exerciseDate);
+    Real knockOutProbability = defaultCurve_.empty() ? Real(0.0) : Real(1.0 - defaultCurve_->survivalProbability(exerciseDate));
 
     // adjust forward if option does not knock out (option is on the recovery value if bond defaults before expiry)
     if (!arguments_.knocksOutOnDefault) {
         fwdNpv = (1.0 - knockOutProbability) * fwdNpv + knockOutProbability *
-                                                            (recoveryRate_.empty() ? 0.0 : recoveryRate_->value()) *
+                                                            (recoveryRate_.empty() ? Real(0.0) : Real(recoveryRate_->value())) *
                                                             arguments_.underlying->notional(exerciseDate);
     }
 
@@ -164,7 +164,7 @@ void BlackBondOptionEngine::calculate() const {
     // results_.additionalResults["DirtyBondPrice"] = arguments_.underlying->dirtyPrice();
     if (!arguments_.knocksOutOnDefault) {
         results_.additionalResults["ExpectedBondRecovery"] = knockOutProbability *
-                                                             (recoveryRate_.empty() ? 0.0 : recoveryRate_->value()) *
+                                                             (recoveryRate_.empty() ? Real(0.0) : Real(recoveryRate_->value())) *
                                                              arguments_.underlying->notional(exerciseDate);
     }
     results_.value = optionValue;
diff --git a/QuantExt/qle/pricingengines/blackindexcdsoptionengine.cpp b/QuantExt/qle/pricingengines/blackindexcdsoptionengine.cpp
index 44dafa5..3405333 100644
--- a/QuantExt/qle/pricingengines/blackindexcdsoptionengine.cpp
+++ b/QuantExt/qle/pricingengines/blackindexcdsoptionengine.cpp
@@ -164,7 +164,7 @@ void BlackIndexCdsOptionEngine::priceStrikeCalculate(Real fep) const {
         results_.additionalResults["discountToExerciseSwapCurrency"] = discSwapCurrToExercise;
         results_.additionalResults["upfront"] =
             npv *
-            (arguments_.settlementType == Settlement::Cash ? discTradeCollToExercise / discSwapCurrToExercise : 1.0);
+            (arguments_.settlementType == Settlement::Cash ? Real(discTradeCollToExercise / discSwapCurrToExercise) : Real(1.0));
         results_.additionalResults["forwardPrice"] = forwardPrice;
         results_.additionalResults["fepAdjustedForwardPrice"] = Fp;
         results_.additionalResults["volatility"] = volatility;
diff --git a/QuantExt/qle/pricingengines/discountingfxforwardengine.cpp b/QuantExt/qle/pricingengines/discountingfxforwardengine.cpp
index 965f3ab..8f9cc54 100644
--- a/QuantExt/qle/pricingengines/discountingfxforwardengine.cpp
+++ b/QuantExt/qle/pricingengines/discountingfxforwardengine.cpp
@@ -97,8 +97,8 @@ void DiscountingFxForwardEngine::calculate() const {
 
         Real discNear = settleCcy1 ? disc1near : disc2near;
         Real discFar = settleCcy1 ? disc1far : disc2far;
-        Real fx1 = settleCcy1 ? 1.0 : fxfwd;
-        Real fx2 = settleCcy1 ? 1 / fxfwd : 1.0;
+        Real fx1 = settleCcy1 ? Real(1.0) : Real(fxfwd);
+        Real fx2 = settleCcy1 ? Real(1.0 / fxfwd) : Real(1.0);
 
         QL_REQUIRE(arguments_.isPhysicallySettled || arguments_.payDate <= arguments_.fixingDate ||
                        arguments_.fxIndex != nullptr,
diff --git a/QuantExt/qle/pricingengines/mclgmfwdbondengine.cpp b/QuantExt/qle/pricingengines/mclgmfwdbondengine.cpp
index 7111e6b..576a984 100644
--- a/QuantExt/qle/pricingengines/mclgmfwdbondengine.cpp
+++ b/QuantExt/qle/pricingengines/mclgmfwdbondengine.cpp
@@ -41,7 +41,7 @@ void McLgmFwdBondEngine::setMember() const {
     }
 
     // set interim results for both payoff and amc calculator
-    cmpPayment_ = cmpPaymentDate >= npvDate ? cmpPayment : 0.0;
+    cmpPayment_ = cmpPaymentDate >= npvDate ? Real(cmpPayment) : Real(0.0);
 
     // the case of dirty strike corresponds here to an accrual of 0.0. This will be convenient in the code.
     accruedAmount_ = arguments_.settlementDirty
@@ -85,10 +85,10 @@ void McLgmFwdBondEngine::calculate() const {
 
     // take result from base engine, this depends on the pathvaluedirty only (i.e. no regression model -> no
     // compounding) the raw (untouched) pathvaluedirty is the underlying bond value at disounted to t0
-    double forwardBondValue = resultUnderlyingNpv_ / incomeCurve_->discount(incomeCurveDate_);
+    Real forwardBondValue = resultUnderlyingNpv_ / incomeCurve_->discount(incomeCurveDate_);
 
     // vanilla forward bond calculation
-    double forwardContractForwardValue = (arguments_.isLong ? 1.0 : -1.0) *
+    Real forwardContractForwardValue = (arguments_.isLong ? 1.0 : -1.0) *
                                          (forwardBondValue - accruedAmount_ - arguments_.strikeAmount) *
                                          arguments_.bondNotional;
 
@@ -96,7 +96,7 @@ void McLgmFwdBondEngine::calculate() const {
     forwardContractForwardValue /= conversionFactor();
 
     // include compensation payments
-    double forwardContractPresentValue = forwardContractForwardValue * contractCurve_->discount(contractCurveDate_) -
+    Real forwardContractPresentValue = forwardContractForwardValue * contractCurve_->discount(contractCurveDate_) -
                                          cmpPayment_ * contractCurve_->discount(cmpPaymentDate_);
 
     results_.value = forwardContractPresentValue;
@@ -119,7 +119,7 @@ McLgmFwdBondEngine::overwritePathValueUndDirty(double t, const RandomVariable& p
                                                const std::set<Real>& exerciseXvaTimes,
                                                const std::vector<std::vector<QuantExt::RandomVariable>>& paths) const {
 
-    double fwdMaturity = time(arguments_.fwdMaturityDate);
+    Real fwdMaturity = time(arguments_.fwdMaturityDate);
     if (t < fwdMaturity) {
 
         Size ind = std::distance(exerciseXvaTimes.begin(), exerciseXvaTimes.find(t));
@@ -133,7 +133,7 @@ McLgmFwdBondEngine::overwritePathValueUndDirty(double t, const RandomVariable& p
             t, paths[ind][model_->pIdx(CrossAssetModel::AssetType::IR, 0)], contractCurve_);
 
         // compounding with income curve from t to fwd_maturity T
-        double compoundingTime = time(incomeCurveDate_);
+        Real compoundingTime = time(incomeCurveDate_);
         auto incomeCompounding = lgmVectorised_[0].discountBond(
             t, compoundingTime, paths[ind][model_->pIdx(CrossAssetModel::AssetType::IR, 0)], incomeCurve_);
 
@@ -166,9 +166,9 @@ std::vector<QuantExt::RandomVariable> McLgmFwdBondEngine::FwdBondAmcCalculator::
                    << ") required - internal error.");
 
     // convert dates to times
-    double maturityTime = engine_->time(engine_->arguments_.fwdMaturityDate);
-    double contractCurveTime = engine_->time(engine_->contractCurveDate_);
-    double cmpPaymentTime = engine_->time(engine_->cmpPaymentDate_);
+    Real maturityTime = engine_->time(engine_->arguments_.fwdMaturityDate);
+    Real contractCurveTime = engine_->time(engine_->contractCurveDate_);
+    Real cmpPaymentTime = engine_->time(engine_->cmpPaymentDate_);
 
     // bool stickyCloseOutRun = false;
     std::size_t regModelIndex = 0;
diff --git a/QuantExt/qle/pricingengines/mclgmfwdbondengine.hpp b/QuantExt/qle/pricingengines/mclgmfwdbondengine.hpp
index 0ff4962..e2a85a2 100644
--- a/QuantExt/qle/pricingengines/mclgmfwdbondengine.hpp
+++ b/QuantExt/qle/pricingengines/mclgmfwdbondengine.hpp
@@ -81,7 +81,7 @@ public:
 
     void calculate() const override;
     void setMember() const;
-    double conversionFactor() const { return conversionFactor_->value(); } ;
+    Real conversionFactor() const { return conversionFactor_->value(); } ;
 
     RandomVariable
     overwritePathValueUndDirty(double t, const RandomVariable& pathValueUndDirty,
diff --git a/QuantExt/qle/pricingengines/mcmultilegbaseengine.hpp b/QuantExt/qle/pricingengines/mcmultilegbaseengine.hpp
index f6aa734..5fac2c3 100644
--- a/QuantExt/qle/pricingengines/mcmultilegbaseengine.hpp
+++ b/QuantExt/qle/pricingengines/mcmultilegbaseengine.hpp
@@ -151,7 +151,7 @@ public:
     // results, these are read from derived engines
     mutable Real resultUnderlyingNpv_, resultValue_;
 
-    static constexpr Real tinyTime = 1E-10;
+    static inline const Real tinyTime = 1E-10;
 
     // data structure storing info needed to generate the amount for a cashflow
     struct CashflowInfo {
