diff --git a/qle/pricingengines/discountingbondtrsengine.cpp b/qle/pricingengines/discountingbondtrsengine.cpp
index e43e2e9..ed18301 100644
--- a/qle/pricingengines/discountingbondtrsengine.cpp
+++ b/qle/pricingengines/discountingbondtrsengine.cpp
@@ -99,9 +99,9 @@ void DiscountingBondTRSEngine::calculate() const {
             Real S = 1.0;
 
             if (survivalWeightedFundingReturnCashflows_) {
-                S = (treatSecuritySpreadAsCreditSpread_ ? exp(-bondSpread->value() / (1.0 - recoveryVal) *
-                                                              discountCurve_->timeFromReference(c->date()))
-                                                        : 1.0) *
+                S = (treatSecuritySpreadAsCreditSpread_ ? Real(exp(-bondSpread->value() / (1.0 - recoveryVal) *
+                                                              discountCurve_->timeFromReference(c->date())))
+                                                        : Real(1.0)) *
                     bondDefaultCurve->survivalProbability(c->date());
             }
 
@@ -147,8 +147,8 @@ void DiscountingBondTRSEngine::calculate() const {
 
         if (survivalWeightedFundingReturnCashflows_) {
             S = (treatSecuritySpreadAsCreditSpread_
-                     ? exp(-bondSpread->value() / (1.0 - recoveryVal) * discountCurve_->timeFromReference(c->date()))
-                     : 1.0) *
+                     ? Real(exp(-bondSpread->value() / (1.0 - recoveryVal) * discountCurve_->timeFromReference(c->date())))
+                     : Real(1.0)) *
                 bondDefaultCurve->survivalProbability(c->date());
         }
 
@@ -249,11 +249,11 @@ void DiscountingBondTRSEngine::calculate() const {
         Date fxFixingDate = bondFlowValuationDate;
         if (arguments_.fxIndex)
             fxFixingDate = arguments_.fxIndex->fixingCalendar().adjust(fxFixingDate, Preceding);
-        Real fx = arguments_.fxIndex ? arguments_.fxIndex->fixing(fxFixingDate) : 1.0;
+        Real fx = arguments_.fxIndex ? Real(arguments_.fxIndex->fixing(fxFixingDate)) : Real(1.0);
         Real S =
             (treatSecuritySpreadAsCreditSpread_
-                 ? exp(-bondSpread->value() / (1.0 - recoveryVal) * discountCurve_->timeFromReference(bondFlowPayDate))
-                 : 1.0) *
+                 ? Real(exp(-bondSpread->value() / (1.0 - recoveryVal) * discountCurve_->timeFromReference(bondFlowPayDate)))
+                 : Real(1.0)) *
             bondDefaultCurve->survivalProbability(bondFlowPayDate);
 
         // 5e set bond cashflow and additional results
diff --git a/qle/pricingengines/discountingswapenginedeltagamma.cpp b/qle/pricingengines/discountingswapenginedeltagamma.cpp
index f8ff0f7..0c3a998 100644
--- a/qle/pricingengines/discountingswapenginedeltagamma.cpp
+++ b/qle/pricingengines/discountingswapenginedeltagamma.cpp
@@ -289,19 +289,19 @@ Matrix rebucketGammas(const std::vector<Time>& gammaTimes, const std::map<Date,
             if (i1 >= 0) {
                 if (i2 < n - 1)
                     gammadf[i1][i2 + 1] += w1 * (1.0 - w2) * i->second *
-                                           (linearInZero ? 1.0 : gammaTimes[b1 - 1] * gammaTimes[b2] / (t1 * t2));
+                                           (linearInZero ? Real(1.0) : Real(gammaTimes[b1 - 1] * gammaTimes[b2] / (t1 * t2)));
                 if (i2 >= 0) {
                     gammadf[i1][i2] += w1 * w2 * i->second *
-                                       (linearInZero ? 1.0 : gammaTimes[b1 - 1] * gammaTimes[b2 - 1] / (t1 * t2));
+                                       (linearInZero ? Real(1.0) : Real(gammaTimes[b1 - 1] * gammaTimes[b2 - 1] / (t1 * t2)));
                 }
             }
             if (i2 >= 0 && i1 < n - 1) {
                 gammadf[i1 + 1][i2] += (1.0 - w1) * w2 * i->second *
-                                       (linearInZero ? 1.0 : gammaTimes[b1] * gammaTimes[b2 - 1] / (t1 * t2));
+                                       (linearInZero ? Real(1.0) : Real(gammaTimes[b1] * gammaTimes[b2 - 1] / (t1 * t2)));
             }
             if (i1 < n - 1 && i2 < n - 1) {
                 gammadf[i1 + 1][i2 + 1] += (1.0 - w1) * (1.0 - w2) * i->second *
-                                           (linearInZero ? 1.0 : gammaTimes[b1] * gammaTimes[b2] / (t1 * t2));
+                                           (linearInZero ? Real(1.0) : Real(gammaTimes[b1] * gammaTimes[b2] / (t1 * t2)));
             }
         }
         for (int i = 0; i < n; ++i) {
@@ -342,28 +342,28 @@ Matrix rebucketGammas(const std::vector<Time>& gammaTimes, const std::map<Date,
         if (i1 >= 0) {
             if (i2 < n - 1) {
                 gamma[n + i1][n + i2 + 1] +=
-                    w1 * (1.0 - w2) * tmp * (linearInZero ? 1.0 : gammaTimes[b1 - 1] * gammaTimes[b2] / (t1 * t2));
+                    w1 * (1.0 - w2) * tmp * (linearInZero ? Real(1.0) : Real(gammaTimes[b1 - 1] * gammaTimes[b2] / (t1 * t2)));
                 gamma[n + i2 + 1][n + i1] +=
-                    w1 * (1.0 - w2) * tmp * (linearInZero ? 1.0 : gammaTimes[b1 - 1] * gammaTimes[b2] / (t1 * t2));
+                    w1 * (1.0 - w2) * tmp * (linearInZero ? Real(1.0) : Real(gammaTimes[b1 - 1] * gammaTimes[b2] / (t1 * t2)));
             }
             if (i2 >= 0) {
                 gamma[n + i1][n + i2] +=
-                    w1 * w2 * tmp * (linearInZero ? 1.0 : gammaTimes[b1 - 1] * gammaTimes[b2 - 1] / (t1 * t2));
+                    w1 * w2 * tmp * (linearInZero ? Real(1.0) : Real(gammaTimes[b1 - 1] * gammaTimes[b2 - 1] / (t1 * t2)));
                 gamma[n + i2][n + i1] +=
-                    w1 * w2 * tmp * (linearInZero ? 1.0 : gammaTimes[b1 - 1] * gammaTimes[b2 - 1] / (t1 * t2));
+                    w1 * w2 * tmp * (linearInZero ? Real(1.0) : Real(gammaTimes[b1 - 1] * gammaTimes[b2 - 1] / (t1 * t2)));
             }
         }
         if (i2 >= 0 && i1 < n - 1) {
             gamma[n + i1 + 1][n + i2] +=
-                (1.0 - w1) * w2 * tmp * (linearInZero ? 1.0 : gammaTimes[b1] * gammaTimes[b2 - 1] / (t1 * t2));
+                (1.0 - w1) * w2 * tmp * (linearInZero ? Real(1.0) : Real(gammaTimes[b1] * gammaTimes[b2 - 1] / (t1 * t2)));
             gamma[n + i2][n + i1 + 1] +=
-                (1.0 - w1) * w2 * tmp * (linearInZero ? 1.0 : gammaTimes[b1] * gammaTimes[b2 - 1] / (t1 * t2));
+                (1.0 - w1) * w2 * tmp * (linearInZero ? Real(1.0) : Real(gammaTimes[b1] * gammaTimes[b2 - 1] / (t1 * t2)));
         }
         if (i1 < n - 1 && i2 < n - 1) {
             gamma[n + i1 + 1][n + i2 + 1] +=
-                (1.0 - w1) * (1.0 - w2) * tmp * (linearInZero ? 1.0 : gammaTimes[b1] * gammaTimes[b2] / (t1 * t2));
+                (1.0 - w1) * (1.0 - w2) * tmp * (linearInZero ? Real(1.0) : Real(gammaTimes[b1] * gammaTimes[b2] / (t1 * t2)));
             gamma[n + i2 + 1][n + i1 + 1] +=
-                (1.0 - w1) * (1.0 - w2) * tmp * (linearInZero ? 1.0 : gammaTimes[b1] * gammaTimes[b2] / (t1 * t2));
+                (1.0 - w1) * (1.0 - w2) * tmp * (linearInZero ? Real(1.0) : Real(gammaTimes[b1] * gammaTimes[b2] / (t1 * t2)));
         }
     }
 
diff --git a/qle/pricingengines/numericalintegrationindexcdsoptionengine.cpp b/qle/pricingengines/numericalintegrationindexcdsoptionengine.cpp
index 8f31ce4..b77e70e 100644
--- a/qle/pricingengines/numericalintegrationindexcdsoptionengine.cpp
+++ b/qle/pricingengines/numericalintegrationindexcdsoptionengine.cpp
@@ -61,7 +61,7 @@ void NumericalIntegrationIndexCdsOptionEngine::doCalc() const {
         results_.additionalResults["discountToExerciseSwapCurrency"] = discSwapCurrToExercise;
         results_.additionalResults["upfront"] =
             underlyingNpv *
-            (arguments_.settlementType == Settlement::Cash ? discTradeCollToExercise / discSwapCurrToExercise : 1.0);
+            (arguments_.settlementType == Settlement::Cash ? Real(discTradeCollToExercise / discSwapCurrToExercise) : Real(1.0));
         results_.additionalResults["valuationDateNotional"] = arguments_.swap->notional();
         results_.additionalResults["tradeDateNotional"] = arguments_.tradeDateNtl;
         results_.additionalResults["callPut"] =
diff --git a/qle/pricingengines/numericlgmbgsflexiswapengine.cpp b/qle/pricingengines/numericlgmbgsflexiswapengine.cpp
index 7320fd4..7db7530 100644
--- a/qle/pricingengines/numericlgmbgsflexiswapengine.cpp
+++ b/qle/pricingengines/numericlgmbgsflexiswapengine.cpp
@@ -67,7 +67,7 @@ void NumericLgmBgsFlexiSwapEngine::calculate() const {
         if (i > 0) {
             // ratio of zero-cpr notionals
             Real amortisationRate =
-                QuantLib::close_enough(aggregatePrincipal, 0.0) ? 0.0 : (aggregatePrincipal / lastAggregatePrincipal);
+                QuantLib::close_enough(aggregatePrincipal, 0.0) ? Real(0.0) : Real(aggregatePrincipal / lastAggregatePrincipal);
             // we only prepay if the start date of the nominal is in the future
             currentUpperNotionalAfterPrepayment =
                 currentUpperNotionalAfterPrepayment *
