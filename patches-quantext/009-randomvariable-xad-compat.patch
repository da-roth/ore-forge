diff --git a/qle/math/randomvariable.cpp b/qle/math/randomvariable.cpp
index 05ec18b..967244a 100644
--- a/qle/math/randomvariable.cpp
+++ b/qle/math/randomvariable.cpp
@@ -45,6 +45,16 @@
 namespace QuantExt {
 
 namespace {
+// XAD compatibility: extract double value from Real
+// Works with both xad::AReal and plain double types
+template<typename T>
+inline double toDouble(const T& x) {
+    if constexpr (std::is_same_v<std::decay_t<T>, double>) {
+        return x;
+    } else {
+        return static_cast<double>(x.value());
+    }
+}
 
 #ifdef ENABLE_RANDOMVARIABLE_STATS
 
@@ -385,7 +395,7 @@ RandomVariable& RandomVariable::operator=(RandomVariable&& r) {
 }
 
 RandomVariable::RandomVariable(const Size n, const Real value, const Real time)
-    : n_(n), constantData_(value), data_(nullptr), deterministic_(n != 0), time_(time) {}
+    : n_(n), constantData_(toDouble(value)), data_(nullptr), deterministic_(n != 0), time_(time) {}
 
 RandomVariable::RandomVariable(const Filter& f, const Real valueTrue, const Real valueFalse, const Real time) {
     if (!f.initialised()) {
@@ -483,7 +493,7 @@ void RandomVariable::setAll(const Real v) {
         delete[] data_;
         data_ = nullptr;
     }
-    constantData_ = v;
+    constantData_ = toDouble(v);
     deterministic_ = true;
 }
 
@@ -560,7 +570,7 @@ RandomVariable& RandomVariable::operator+=(const RandomVariable& y) {
     else {
         resumeCalcStats();
         for (Size i = 0; i < n_; ++i) {
-            data_[i] += y[i];
+            data_[i] = data_[i] + toDouble(y[i]);
         }
         stopCalcStats(n_);
     }
@@ -584,7 +594,7 @@ RandomVariable& RandomVariable::operator-=(const RandomVariable& y) {
     else {
         resumeCalcStats();
         for (Size i = 0; i < n_; ++i) {
-            data_[i] -= y[i];
+            data_[i] = data_[i] - toDouble(y[i]);
         }
         stopCalcStats(n_);
     }
@@ -608,7 +618,7 @@ RandomVariable& RandomVariable::operator*=(const RandomVariable& y) {
     else {
         resumeCalcStats();
         for (Size i = 0; i < n_; ++i) {
-            data_[i] *= y[i];
+            data_[i] = data_[i] * toDouble(y[i]);
         }
         stopCalcStats(n_);
     }
@@ -632,7 +642,7 @@ RandomVariable& RandomVariable::operator/=(const RandomVariable& y) {
     else {
         resumeCalcStats();
         for (Size i = 0; i < n_; ++i) {
-            data_[i] /= y[i];
+            data_[i] = data_[i] / toDouble(y[i]);
         }
         stopCalcStats(n_);
     }
@@ -680,7 +690,7 @@ RandomVariable max(RandomVariable x, const RandomVariable& y) {
     else {
         resumeCalcStats();
         for (Size i = 0; i < x.size(); ++i) {
-            x.data_[i] = std::max(x.data_[i], y[i]);
+            x.data_[i] = std::max(x.data_[i], toDouble(y[i]));
         }
         stopCalcStats(x.size());
     }
@@ -700,7 +710,7 @@ RandomVariable min(RandomVariable x, const RandomVariable& y) {
     else {
         resumeCalcStats();
         for (Size i = 0; i < x.size(); ++i) {
-            x.data_[i] = std::min(x.data_[i], y[i]);
+            x.data_[i] = std::min(x.data_[i], toDouble(y[i]));
         }
         stopCalcStats(x.size());
     }
@@ -722,7 +732,7 @@ RandomVariable pow(RandomVariable x, const RandomVariable& y) {
     else {
         resumeCalcStats();
         for (Size i = 0; i < x.size(); ++i) {
-            x.data_[i] = std::pow(x.data_[i], y[i]);
+            x.data_[i] = std::pow(x.data_[i], toDouble(y[i]));
         }
         stopCalcStats(x.size());
     }
@@ -916,11 +926,11 @@ RandomVariable indicatorEq(RandomVariable x, const RandomVariable& y, const Real
     if (!y.deterministic_)
         x.expand();
     if (x.deterministic()) {
-        x.constantData_ = QuantLib::close_enough(x.constantData_, y.constantData_) ? trueVal : falseVal;
+        x.constantData_ = QuantLib::close_enough(x.constantData_, y.constantData_) ? toDouble(trueVal) : toDouble(falseVal);
     } else {
         resumeCalcStats();
         for (Size i = 0; i < x.n_; ++i) {
-            x.data_[i] = QuantLib::close_enough(x.data_[i], y[i]) ? trueVal : falseVal;
+            x.data_[i] = QuantLib::close_enough(x.data_[i], y[i]) ? toDouble(trueVal) : toDouble(falseVal);
         }
         stopCalcStats(x.n_);
     }
@@ -944,7 +954,7 @@ RandomVariable indicatorGt(RandomVariable x, const RandomVariable& y, const Real
             Real delta = getDelta(x - y, eps);
             resumeCalcStats();
             for (Size i = 0; i < x.n_; ++i) {
-                x.data_[i] = falseVal + (trueVal - falseVal) * 1.0 / (1.0 + std::exp(-x.data_[i] / delta));
+                x.data_[i] = toDouble(falseVal + (trueVal - falseVal) * 1.0 / (1.0 + std::exp(-x.data_[i] / toDouble(delta))));
             }
             stopCalcStats(x.n_);
             return x;
@@ -958,7 +968,7 @@ RandomVariable indicatorGt(RandomVariable x, const RandomVariable& y, const Real
     } else {
         resumeCalcStats();
         for (Size i = 0; i < x.n_; ++i) {
-            x.data_[i] = (x.data_[i] > y[i] && !QuantLib::close_enough(x.data_[i], y[i])) ? trueVal : falseVal;
+            x.data_[i] = (x.data_[i] > y[i] && !QuantLib::close_enough(x.data_[i], y[i])) ? toDouble(trueVal) : toDouble(falseVal);
         }
         stopCalcStats(x.n_);
     }
@@ -982,7 +992,7 @@ RandomVariable indicatorGeq(RandomVariable x, const RandomVariable& y, const Rea
             Real delta = getDelta(x - y, eps);
             resumeCalcStats();
             for (Size i = 0; i < x.n_; ++i) {
-                x.data_[i] = falseVal + (trueVal - falseVal) * 1.0 / (1.0 + std::exp(-x.data_[i] / delta));
+                x.data_[i] = toDouble(falseVal + (trueVal - falseVal) * 1.0 / (1.0 + std::exp(-x.data_[i] / toDouble(delta))));
             }
             stopCalcStats(x.n_);
             return x;
@@ -996,7 +1006,7 @@ RandomVariable indicatorGeq(RandomVariable x, const RandomVariable& y, const Rea
     } else {
         resumeCalcStats();
         for (Size i = 0; i < x.n_; ++i) {
-            x.data_[i] = (x.data_[i] > y[i] || QuantLib::close_enough(x.data_[i], y[i])) ? trueVal : falseVal;
+            x.data_[i] = (x.data_[i] > y[i] || QuantLib::close_enough(x.data_[i], y[i])) ? toDouble(trueVal) : toDouble(falseVal);
         }
         stopCalcStats(x.n_);
     }
diff --git a/qle/math/randomvariable.hpp b/qle/math/randomvariable.hpp
index 7582b14..28efab2 100644
--- a/qle/math/randomvariable.hpp
+++ b/qle/math/randomvariable.hpp
@@ -36,6 +36,17 @@
 #include <set>
 
 namespace QuantExt {
+// XAD compatibility: extract double value from Real
+namespace detail {
+template<typename T>
+inline double toDouble(const T& x) {
+    if constexpr (std::is_same_v<std::decay_t<T>, double>) {
+        return x;
+    } else {
+        return static_cast<double>(x.value());
+    }
+}
+} // namespace detail
 
 using namespace QuantLib;
 
@@ -362,7 +373,7 @@ inline void RandomVariable::set(const Size i, const Real v) {
             return;
         }
     }
-    data_[i] = v;
+    data_[i] = detail::toDouble(v);
 }
 
 inline Real RandomVariable::operator[](const Size i) const {
