diff --git a/QuantExt/qle/pricingengines/commodityspreadoptionengine.cpp b/QuantExt/qle/pricingengines/commodityspreadoptionengine.cpp
index 27feb3b..07c1ada 100644
--- a/QuantExt/qle/pricingengines/commodityspreadoptionengine.cpp
+++ b/QuantExt/qle/pricingengines/commodityspreadoptionengine.cpp
@@ -71,7 +71,7 @@ void CommoditySpreadOptionAnalyticalEngine::calculate() const {
 
     QL_REQUIRE(paymentDate >= exerciseDate, "Payment date needs to be on or after exercise date");
 
-    double df = discountCurve_->discount(paymentDate);
+    Real df = discountCurve_->discount(paymentDate);
 
     Time ttp = discountCurve_->timeFromReference(paymentDate);
     Time tte = discountCurve_->timeFromReference(exerciseDate);
@@ -89,26 +89,26 @@ void CommoditySpreadOptionAnalyticalEngine::calculate() const {
                    QuantLib::close_enough(parameterFlow1.displacement, parameterFlow2.displacement),
                "Displacements of long and short asset must be the same, got " << parameterFlow1.displacement << " and "
                                                                               << parameterFlow2.displacement);
-    double F1 = parameterFlow1.atm;
-    double F2 = parameterFlow2.atm;
-    double sigma1 = parameterFlow1.sigma;
-    double sigma2 = parameterFlow2.sigma;
-    double pricingTime1 = parameterFlow1.tn;
-    double pricingTime2 = parameterFlow2.tn;
-    double obsTime1 = std::min(tte, pricingTime1);
-    double obsTime2 = std::min(tte, pricingTime2);
-    double accruals1 = parameterFlow1.accruals;
-    double accruals2 = parameterFlow2.accruals;
+    Real F1 = parameterFlow1.atm;
+    Real F2 = parameterFlow2.atm;
+    Real sigma1 = parameterFlow1.sigma;
+    Real sigma2 = parameterFlow2.sigma;
+    Real pricingTime1 = parameterFlow1.tn;
+    Real pricingTime2 = parameterFlow2.tn;
+    Real obsTime1 = std::min(tte, pricingTime1);
+    Real obsTime2 = std::min(tte, pricingTime2);
+    Real accruals1 = parameterFlow1.accruals;
+    Real accruals2 = parameterFlow2.accruals;
 
-    double sigma = 0;
-    double stdDev = 0;
-    double Y = 0;
-    double Z = 0;
-    double sigmaY = 0;
-    double w1 = arguments_.longAssetFlow->gearing();
-    double w2 = arguments_.shortAssetFlow->gearing();
+    Real sigma = 0;
+    Real stdDev = 0;
+    Real Y = 0;
+    Real Z = 0;
+    Real sigmaY = 0;
+    Real w1 = arguments_.longAssetFlow->gearing();
+    Real w2 = arguments_.shortAssetFlow->gearing();
     // Adjust strike for past fixings
-    double effectiveStrike = arguments_.effectiveStrike - w1 * accruals1 + w2 * accruals2;
+    Real effectiveStrike = arguments_.effectiveStrike - w1 * accruals1 + w2 * accruals2;
     Real correlation = QuantLib::Null<Real>();
     
     bool useBachelier = parameterFlow1.volType == VolatilityType::Normal;
@@ -117,7 +117,7 @@ void CommoditySpreadOptionAnalyticalEngine::calculate() const {
     } else if (exerciseDate <= today && paymentDate > today) {
         // if observation time is before expiry, continue the process with zero vol and zero drift from pricing date to
         // expiry
-        double omega = arguments_.type == Option::Call ? 1 : -1;
+        Real omega = arguments_.type == Option::Call ? 1 : -1;
 
         results_.value = df * arguments_.quantity * omega * std::max(w1 * F1 - w2 * F2 - effectiveStrike, 0.0);
 
@@ -219,11 +219,11 @@ CommoditySpreadOptionAnalyticalEngine::derivePricingParameterFromFlow(const ext:
         // In case exercise is after future expiry (e.g. calendar spreads)
         auto pricingDate = std::min(exerciseDate, cf->pricingDate());
         res.tn = std::max(vol->timeFromReference(pricingDate), 0.0);
-        double fxSpot = 1.0;
+        Real fxSpot = 1.0;
         if (fxIndex) {
             fxSpot = fxIndex->fixing(pricingDate);
         }
-        double atmUnderlyingCurrency = cf->index()->fixing(pricingDate);
+        Real atmUnderlyingCurrency = cf->index()->fixing(pricingDate);
         res.atm = atmUnderlyingCurrency * fxSpot;
         res.sigma = 0;
         if (res.tn > 0 && !QuantLib::close_enough(res.tn, 0.0)) {
diff --git a/QuantExt/qle/pricingengines/commodityspreadoptionengine.hpp b/QuantExt/qle/pricingengines/commodityspreadoptionengine.hpp
index b068a5a..2927236 100644
--- a/QuantExt/qle/pricingengines/commodityspreadoptionengine.hpp
+++ b/QuantExt/qle/pricingengines/commodityspreadoptionengine.hpp
@@ -70,7 +70,7 @@ private:
                                                     const ext::shared_ptr<FxIndex>& fxIndex) const;
 
     //! Return the correlation between two future expiry dates \p ed_1 and \p ed_2
-    double intraAssetCorrelation(const QuantLib::Date& e1, const QuantLib::Date& e2,
+    Real intraAssetCorrelation(const QuantLib::Date& e1, const QuantLib::Date& e2,
                                   const ext::shared_ptr<BlackVolTermStructure>& vol) const;
 
     double rho() const;
