diff --git a/ql/pricingengines/diffusioncalculator.cpp b/ql/pricingengines/diffusioncalculator.cpp
index df88638..f06ee85 100644
--- a/ql/pricingengines/diffusioncalculator.cpp
+++ b/ql/pricingengines/diffusioncalculator.cpp
@@ -29,18 +29,18 @@ namespace QuantLib {
         double forward, double strike, double ttm, double nVol, double displacement) {
         QL_REQUIRE(!close_enough(forward, 0.0), "forward is 0.0, can not convert normal vol to shifted lognormal vol");
         auto optionType = forward > strike ? Option::Type::Put : Option::Type::Call;
-        double premium = bachelierBlackFormula(optionType, strike, forward, nVol * std::sqrt(ttm));
-        double slnVol =
+        Real premium = bachelierBlackFormula(optionType, strike, forward, nVol * std::sqrt(ttm));
+        Real slnVol =
             blackFormulaImpliedStdDev(optionType, strike, forward, premium, 1.0, displacement, nVol / forward );
-        return slnVol / sqrt(ttm);
+        return xad::value(slnVol / sqrt(ttm));
     }
 
     double convertShiftedLognormalToNormalVol(
         double forward, double strike, double ttm, double slnVol, double displacement) {
         auto optionType = forward > strike ? Option::Type::Put : Option::Type::Call;
-        double price = blackFormula(optionType, strike, forward, slnVol * std::sqrt(ttm), 1.0, displacement);
-        double nVol = bachelierBlackFormulaImpliedVol(optionType, strike, forward, ttm, price);
-        return nVol;
+        Real price = blackFormula(optionType, strike, forward, slnVol * std::sqrt(ttm), 1.0, displacement);
+        Real nVol = bachelierBlackFormulaImpliedVol(optionType, strike, forward, ttm, price);
+        return xad::value(nVol);
     }
 
     double convertShiftedLognormalToShiftedLognormalVol(
@@ -49,10 +49,10 @@ namespace QuantLib {
         if (close_enough(oldDisplacement, newDisplacement))
             return slnVol;
         auto optionType = forward > strike ? Option::Type::Put : Option::Type::Call;
-        double price = blackFormula(optionType, strike, forward, slnVol, 1.0, oldDisplacement);
-        double newSlnVol =
+        Real price = blackFormula(optionType, strike, forward, slnVol, 1.0, oldDisplacement);
+        Real newSlnVol =
             blackFormulaImpliedStdDev(optionType, strike, forward, price, 1.0, newDisplacement);
-        return newSlnVol / sqrt(ttm);
+        return xad::value(newSlnVol / sqrt(ttm));
     }
 
     std::tuple<double, VolatilityType, double>
@@ -78,17 +78,17 @@ namespace QuantLib {
         if (inputVolType == VolatilityType::ShiftedLognormal &&
             targetVolType == VolatilityType::Normal) {
             double slnVol = inputVol;
-            double nVol =
+            Real nVol =
                 convertShiftedLognormalToNormalVol(forward, strike, t, slnVol, inputDisplacement);
-            return std::make_tuple(nVol, VolatilityType::Normal, targetDisplacement);
+            return std::make_tuple(xad::value(nVol), VolatilityType::Normal, targetDisplacement);
         }
 
         if (inputVolType == VolatilityType::Normal &&
             targetVolType == VolatilityType::ShiftedLognormal) {
             double nVol = inputVol;
-            double slnVol =
+            Real slnVol =
                 convertNormalToShiftedLogNormalVol(forward, strike, t, nVol, targetDisplacement);
-            return std::make_tuple(slnVol, VolatilityType::ShiftedLognormal, targetDisplacement);
+            return std::make_tuple(xad::value(slnVol), VolatilityType::ShiftedLognormal, targetDisplacement);
         }
 
         if (inputVolType == VolatilityType::ShiftedLognormal &&
@@ -96,9 +96,9 @@ namespace QuantLib {
             !close_enough(inputDisplacement, targetDisplacement)) {
             // need to convert the vol to the new displacement
             double slnVol = inputVol;
-            double newSlnVol = convertShiftedLognormalToShiftedLognormalVol(
+            Real newSlnVol = convertShiftedLognormalToShiftedLognormalVol(
                 forward, strike, t, slnVol, inputDisplacement, targetDisplacement);
-            return std::make_tuple(newSlnVol, VolatilityType::ShiftedLognormal,
+            return std::make_tuple(xad::value(newSlnVol), VolatilityType::ShiftedLognormal,
                                    targetDisplacement);
         }
 
@@ -115,7 +115,7 @@ namespace QuantLib {
                                        double strike,
                                        double t) {
         return convertInputVolatility(outputModelType, displacement, volTS->volType(),
-                                      volTS->shift(), volTS->blackVol(t, strike), forward, strike,
+                                      xad::value(volTS->shift()), xad::value(volTS->blackVol(t, strike)), forward, strike,
                                       t);
     }
 
